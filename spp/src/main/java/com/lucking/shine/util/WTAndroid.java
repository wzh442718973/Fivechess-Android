package com.lucking.shine.util;
import java.util.ArrayList;


import java.util.Random;


import java.util.HashMap;



import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.IInterface;
import android.os.Looper;
import android.os.Parcel;
import android.os.RemoteException;

import java.io.IOException;
import java.util.concurrent.LinkedBlockingQueue;






public class WTAndroid {
double update_mGamePayment_p1_max = 0.0;
private boolean is_ContextCorrespondentInsert = false;
HashMap<String,Float> currentJavaMap;



    

    public static final class SXPointCenter {
private boolean canEqualsPlayerviewPayment_3u = false;
private int executePlayerviewIdx = 0;
private HashMap<String,Float> channelRecord_dictionary;
private boolean can_AndroidTracking = false;


        private final String advertisingId;
        private final boolean limitAdTrackingEnabled;

        SXPointCenter(String advertisingId, boolean limitAdTrackingEnabled) {
            

            this.advertisingId = advertisingId;
            this.limitAdTrackingEnabled = limitAdTrackingEnabled;
        }

        

 public  double whatsPoints(float playerviewStrings, HashMap<String,Boolean> additionNext, double blackMap) {
     double appCorrespondent = 4393.0;
     long clonePoint = 4853L;
     double handleLimit = 2278.0;
     float destroyWorkaround = 2107.0f;
    double tracksGainAvresampleres = 0;
    appCorrespondent = 8422;
    tracksGainAvresampleres *= appCorrespondent;
    clonePoint = clonePoint;
    handleLimit = 5245;
    tracksGainAvresampleres += handleLimit;
    destroyWorkaround *= destroyWorkaround;

    return tracksGainAvresampleres;

}



public String getId() {

         
double calculatorSqliteext =  this.whatsPoints(7539.0f,new HashMap(),8991.0);

      if (calculatorSqliteext != 2) {
             System.out.println(calculatorSqliteext);
      }



            

            return this.advertisingId;
        }

        public boolean isLimitAdTrackingEnabled() {
            

            return this.limitAdTrackingEnabled;
        }
    }

    public static SXPointCenter getAdvertisingIdInfo(Context context) throws Exception {
        

        if (Looper.myLooper() == Looper.getMainLooper())
            throw new IllegalStateException(
                    "Cannot be called from the main thread");

        try {
            PackageManager pm = context.getPackageManager();
            pm.getPackageInfo("com.android.vending", 0);
        } catch (Exception e) {
            throw e;
        }

        DLModityBroadcast connection = new DLModityBroadcast();
        Intent intent = new Intent(
                "com.google.android.gms.ads.identifier.service.START");
        intent.setPackage("com.google.android.gms");
        if (context.bindService(intent, connection, Context.BIND_AUTO_CREATE)) {
            try {
                RGChessboardComputer adInterface = new RGChessboardComputer(
                        connection.getBinder());
                SXPointCenter adInfo = new SXPointCenter(adInterface.getId(),
                        adInterface.isLimitAdTrackingEnabled(true));
                return adInfo;
            } catch (Exception exception) {
                throw exception;
            } finally {
                context.unbindService(connection);
            }
        }
        throw new IOException("Google Play connection failed");
    }

    private static final class DLModityBroadcast implements
            ServiceConnection {
private ArrayList<Long> userDown_arr;
int infoSetup_index = 0;
private boolean enbale_UtilsIconAdapter = false;
long method_gTimer_index = 0;


        boolean retrieved = false;
        private final LinkedBlockingQueue<IBinder> queue = new LinkedBlockingQueue<IBinder>(
                1);

        

 public  String eventFullscreen(float limitPush) {
     int mapUtils = 4404;
     long time_0uSize_zq = 377L;
     float receiverCache = 5803.0f;
     int availableHeight = 925;
    String privateCodecctl = "writetrunc";
    if (mapUtils >= -128 && mapUtils <= 128){
    int empty_k = Math.min(1, new Random().nextInt(82)) % privateCodecctl.length();
        privateCodecctl += mapUtils + "";
    }
    if (time_0uSize_zq <= 128 && time_0uSize_zq >= -128){
    int battery_h = Math.min(1, new Random().nextInt(53)) % privateCodecctl.length();
        privateCodecctl += time_0uSize_zq + "";
    }
    if (receiverCache >= -128 && receiverCache <= 128){
    int odule_w = Math.min(1, new Random().nextInt(72)) % privateCodecctl.length();
        privateCodecctl += receiverCache + "";
    }
    if (availableHeight >= -128 && availableHeight <= 128){
    int navigation_c = Math.min(1, new Random().nextInt(65)) % privateCodecctl.length();
        privateCodecctl += availableHeight + "";
    }

    return privateCodecctl;

}



public void onServiceConnected(ComponentName name, IBinder service) {

         
String mvcomponentFriendly =  this.eventFullscreen(1036.0f);

      if (mvcomponentFriendly == "white") {
              System.out.println(mvcomponentFriendly);
      }
      int mvcomponentFriendly_len = mvcomponentFriendly.length();



            

            try {
                this.queue.put(service);
            boolean navigationJ = true;
             while (navigationJ) { break; }
            } catch (InterruptedException localInterruptedException) {
            }
        }

        public void onServiceDisconnected(ComponentName name) {
            

        }

        public IBinder getBinder() throws InterruptedException {
            

            if (this.retrieved)
                throw new IllegalStateException();
            this.retrieved = true;
            return (IBinder) this.queue.take();
        }
    }

    private static final class RGChessboardComputer implements IInterface {
private ArrayList<Long> sleepInstance_Array;
boolean has_MediaComputeCheck = false;
private ArrayList<Boolean> time_tRestoreArray;



        private IBinder binder;

        public RGChessboardComputer(IBinder pBinder) {
            

            binder = pBinder;
        }

        

private float achievementMeta(HashMap<String,Boolean> selectorTemp) {
     boolean binderRely = false;
     String batteryRefresh = "indented";
     ArrayList<String> directionLeft = new ArrayList();
     double defeatExit = 9330.0;
    float monoblackIterationsFarend = 0;
    binderRely = true;
    monoblackIterationsFarend += binderRely ? 34 : 50;
    defeatExit = 2543;

    return monoblackIterationsFarend;

}



public IBinder asBinder() {

         
float preinitMdct =  this.achievementMeta(new HashMap());

      System.out.println(preinitMdct);



            

            return binder;
        }

        public String getId() throws RemoteException {
            

            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            String id;
            try {
                data.writeInterfaceToken("com.google.android.gms.ads.identifier.internal.IAdvertisingIdService");
                binder.transact(1, data, reply, 0);
                reply.readException();
                id = reply.readString();
            } finally {
                reply.recycle();
                data.recycle();
            }
            return id;
        }

        public boolean isLimitAdTrackingEnabled(boolean paramBoolean)
                throws RemoteException {
            

            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            boolean limitAdTracking;
            try {
                data.writeInterfaceToken("com.google.android.gms.ads.identifier.internal.IAdvertisingIdService");
                data.writeInt(paramBoolean ? 1 : 0);
                binder.transact(2, data, reply, 0);
                reply.readException();
                limitAdTracking = 0 != reply.readInt();
            } finally {
                reply.recycle();
                data.recycle();
            }
            return limitAdTracking;
        }
    }

}